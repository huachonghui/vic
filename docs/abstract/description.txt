$Id$

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    INTRODUCTION                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

In recent years we have seen a great increase in networked multimedia
applications; many of them greatly prefer to use UDP for transmission because
the variability of TCP's congestion control mechanism and its complete
reliability do not match their timeliness requirements. These applications, such
as streaming media, Internet telephony, and games have in common two key demands
of a transport protocol: 

  - timely packet delivery
  - smooth predictable transmission rate

Proposed congestion control mechanisms to achieve these characteristics include
generalizations of TCP-like window-based schemes (e.g., GAIMD, TEAR, Binomial
TCP) and equation-based congestion control scheme (e.g., TFRC). In this work for
GSoC 2008, we would like to implement the latter cases: TFRC proposed by Floyd
[1] and TFWC proposed by Soo-Hyun [2] over VIC/RAT audio/video applications [3]
using C/C++. 

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
| MOTIVATION                                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

1) does congestion control ever needed?  

One might be able to think that a real-time interactive streaming application
does not ever need the congestion control mechanisms, but in fact we can do much
things using congestion control over those applications. The strong part of the
contribution is that we get the precise control about the end-to-end packet
delay in any kind of networks: congestion control mechanisms can provide the
relevant information to upper layer (e.g., multimedia codecs). Considering the
fact that the delay (and delay jitter) is one of the critical parameters that a
user might greatly care specially for the "interactive" multimedia streaming
applications, the controlled delay using congestion control could bring a
significant advantage to such applications. 

2) then, why TFRC and why TFWC?

As we pointed out already, our target applications prefer smooth and predictable
transmission rate to a TCP-like rate changing behavior. To achieve this goal,
Sally [1] proposed TFRC, a de facto standard, in 2000 and it is gaining a great
popularity: it is also adopted DCCP's CCID3, being standardized by IETF.
However, we have recently observed that TFRC has some limitations such that: 

- It can produce uncontrolled throughput oscillation in a certain network
  conditions [4]
- The TCP throughput equation has the convexity property which resulting
  throughput imbalance [5]
- The difficulty of measuring RTT correctly can result in a long-term throughput
  imbalance [6]

All of the problems above essentially stem from the same basic cause: it is
difficult to build a rate-based protocol with a rate that is directly inverse
proportional to RTT while achieving stability in all conditions. All these
issues beg the question of why TFRC is rate-based at all? We have proposed a
window-based version of TFRC, which uses a TCP-like Ack-clocking feature but
merges this with the use of the TCP throughput equation, ala TFRC, to directly
adjust the sending window size. The goal is to remedy the issues discussed above
which relate to the combination of rate-based control. Using a window makes the
RTT implicit in the Ack clock, and removing the need to be rate-based makes life
much simpler for application writers, as they no longer need to work around the
limitations of the OS's short duration timers. The detailed protocol
description and initial results can be found at [2]. 

In next section, we describe our implementation proposal for GSoC 2008.

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            DETAILED PROPOSAL AND PLAN             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

1) Overview

First, we plan to implement TFRC on VIC using C language.  Given that there is a
similar TFRC implementation [6] over UltraGrid using the UCL common library, we
could leverage their implementation as VIC also uses the same library.  This
includes the APIs with TFRC and RTP/RTCP and some front-end congestion control
options. The reason for the choice of VIC is that the size of video packet is
much larger than that of voice, so we could test larger packet first and then
move on to the smaller size like RAT.

Second, we plan to implement TFWC from the scratch using C. There is a
simulation code implemented on ns-2 [2] using C++, and we hope to use it again
here in VIC. But, we will need to implement from the scratch for its APIs with
RTP/RTCP and integrate with VIC's user interfaces. 

2) Components to be developed

 - TFRC sender/receiver: implement algorithm as described in [1]

 - TFWC sender/receiver: implement algorithm as described in [2]

 - Send Buffer: it is critical to implement send buffer carefully as
   this is the main part to make interact correctly with our congestion 
   control modules. The send buffer should be able to handle RTT calculation,
   update e2e delay, maintain queue, maintain frame length, and finally compute
   the inter-packet-interval.

 - Receive Buffer: the play-out buffer is rather straight forward as it only 
   needs to play the packet streams.

 - Congestion Control (CC) Manager: main CC interfaces with RTP/RTCP. update
   CC's sender/receiver state along with necessary parameters. 

 - APIs: TFR(W)C's APIs in order for the communication with RTP/RTCP. It is
   necessary to make sure that our congestion control modules give/get
   information to/from RTP layer correctly with newly created APIs. 

Apart from the above components, we will need to change quite a bit of VIC main
source code to fit our modules in it. 

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           WHY I AM A STRONG CANDIDATE?            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Implementing a network protocol can be sometimes challenging task as it is often
hard to validate every function in every aspect.  However, I already developed
TFWC on ns-2 and know exact steps how to develop such congestion control
protocols.  Also, AVATS project is now being conducted in the same department
that I'm working on, and I know well the PI and the main developer as we are
just sitting next to each other.  My current research is also based on the part
of their software.  This could be a natural adaptation for us to start
co-working, meaning that we could achieve the goal in a relatively short time
scale with my experience, and it also could be easier to co-work because we are
geographically in the same place.


+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   REFERENCES                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[1] S. Floyd, M. Handley, J. Padhye, and J. Widmer. Equation-based congestion
control for Unicast Applications. In Proc. of ACM SIGCOMM 2000, pages 43-56

[2] S.-H. Choi. Design and Analysis for TCP-Friendly Window-based Congestion
Control. UCL Research Note (RN/06/22), 2006

[3] AVATS. URL: http://www.cs.ucl.ac.uk/research/avats 

[4] S.-H. Choi and M. Handley. Fairer TCP-Friendly Congestion Control Protocol
for Multimedia Streaming Applications, In Proc. of CoNEXT, 2007

[5] I. Rhee and L. Xu. Limitations of Equation-based Congestion Control.
IEEE/ACM ToN, vol. 15, 2007.

[6] A. Saurin. Congestion Control for Video-conferencing Applications. MSc
Thesis, U. of Glasgow, 2006
